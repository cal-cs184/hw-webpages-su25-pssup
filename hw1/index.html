<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}

			.table-container {
				display: flex;
				flex-direction: column;
				align-items: center;
			}

			.table {
				width: 100%;
				text-align: center;
				border-collapse: collapse;
			}
			
			.table td {
				text-align: center;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Summer 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: Seongsoo Park</div>

		<br>

		Link to webpage: <a href="https://cal-cs184.github.io/hw-webpages-su25-pssup/">https://cal-cs184.github.io/hw-webpages-su25-pssup/</a>
		
		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184/hw-webpages-su25-pssup">https://github.com/cal-cs184/hw-webpages-su25-pssup</a>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		<p>In this assignment, I implemented a renderer that can display a simple SVG file as an image using a rasterizer. Starting with drawing a triangle, antialiasing is implemented using supersampling. Then, linear transformations such as translation, scaling, and rotation are implemented. Gradients within the triangle are also implemented using barycentric interpolation. Finally, texture mapping is implemented using mipmaps.</p>

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		<p>The most basic way to rasterize a triangle is to check each point to determine whether it is inside the triangle. For each point inside the bounding box of the triangle, check which side of the line connecting the two points of the triangle the point is on. The formula for checking for a line is as follows:</p>

		\[ L_i(x, y) = -(x - X_i) (Y_{i+1} - Y_i) + (y - Y_i) (X_{i+1} - X_i) \]

		<p>The sign of \( L_i \) determines which side of the line the point is on. The signs of \( L_i \) must be the same for all three lines, and whether this sign is positive or negative when the point is inside the triangle is determined based on whether the vertices of the triangle are oriented clockwise or counterclockwise.</p>

		<p>Note that the check here for each point is performed only within the bounding box of the triangle. The bounding box of a triangle is the smallest rectangle that the triangle can fit inside, and the bounding box can be obtained by finding the minimum and maximum x and y coordinates of the triangle's vertices. Therefore, the algorithm implemented in the code checks each sample within the bounding box of the triangle, which is efficient enough for the purpose.</p>

		<p>Below is an example of rendering an svg file with basic rasterization.</p>
		<figure>
			<img src="./img/screenshot_7-6_23-53-6.png" width="400px"/>
			<figcaption>Basic rasterization</figcaption>
		</figure>

		<p>If you look at the thin section of a triangle here, the shape appears to be "broken". This happens because the triangle's sides pass between the points in the middle of the grid, and the points beyond are included between the triangle's sides. You can see this in the figure below:</p>
		
		<figure>
			<img src="./img/screenshot_7-6_23-52-38.png" width="400px"/>
			<figcaption>Pixel inspection</figcaption>
		</figure>

		<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
		<div class="table-container">
			<table class="table">
			  <tr>
				<td>
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td>
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td>
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td>
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		<p>Supersampling is the process of sampling a pixel using a denser number of samples. It starts with a higher resolution image and then downsamples it to the final output resolution.</p>

		<p>In the rasterization pipeline, there was originally a direct one-to-one correspondence between the pixels of the final output image and the samples output by rasterization. However, after adding supersampling, each pixel corresponds to multiple samples, and the output is the average of each sample. This process makes the image output smoother for the boundaries of shapes, and antialiasing is performed. Supersampling is a useful method for realizing antialiasing through simple ideas and implementations.</p>

		<p>Detailed explanation of the code that implements supersampling: For an image of the original <code>width Ã— height</code>, when <code>sample_rate</code> samples are placed in one pixel, the scaling rate for one axis is <code>sideRate = sqrt(sample_rate)</code>. And in the <code>sample_buffer</code>, the sample at the index <code>y * width * sideRate + x</code> corresponds to the coordinate \( ((x+0.5)/r, (y+0.5)/r) \) where \(r\) is the <code>sideRate</code>. </p>

		<p>The following images show the renders for sample rates of 1, 4, and 16 respectively.</p>

		<div class="table-container">
			<table class="table">
			  <tr>
				<td>
				  <img src="./img/screenshot_7-6_23-56-45.png" width="400px"/>
				  <figcaption>sample rate = 1</figcaption>
				</td>
				<td>
				  <img src="./img/screenshot_7-6_23-57-11.png" width="400px"/>
				  <figcaption>pixel-inspected</figcaption>
				</td>
				</tr>
				<tr>
				<td>
				  <img src="./img/screenshot_7-6_23-56-47.png" width="400px"/>
				  <figcaption>sample rate = 4</figcaption>
				</td>
				<td>
				  <img src="./img/screenshot_7-6_23-57-13.png" width="400px"/>
				  <figcaption>pixel-inspected</figcaption>
				</td>
				</tr>
				<tr>
				<td>
				  <img src="./img/screenshot_7-6_23-56-48.png" width="400px"/>
				  <figcaption>sample rate = 16</figcaption>
				</td>
				<td>
				  <img src="./img/screenshot_7-6_23-57-15.png" width="400px"/>
				  <figcaption>pixel-inspected</figcaption>
				</td>
				</tr>
			</table>
		</div>

		<p>If you look at what happens as the sample rate increases, you can see that the ends of the red triangles are less broken, and the pixels are more continuous and appear blurred. This is because, as the sample rate increases, there are more samples included in the shape, and the shape no longer appears broken.</p>

		<h2>Task 3: Transforms</h2>
		<p>Transformation is the process of moving the coordinates of one point to another, including translation, scaling, and rotation. Linear transformations in homogeneous coordinates are accomplished by multiplying the column vectors \( (x,y,1)^{T} \) representing coordinates by the following matrices.</p>

		For translation:
		\[ \begin{pmatrix}
		1 & 0 & d_{x}\\
		0 & 1 & d_{y}\\
		0 & 0 & 1
		\end{pmatrix} \]

		For scaling:
		\[ \begin{pmatrix}
		s_{x} & 0 & 0\\
		0 & s_{y} & 0\\
		0 & 0 & 1
		\end{pmatrix} \]

		For rotation (counterclockwise):
		\[ \begin{pmatrix}
		\cos{\theta} & -\sin{\theta} & 0\\
		\sin{\theta} & \cos{\theta} & 0\\
		0 & 0 & 1
		\end{pmatrix} \]

		<p>With these transform matrices, the corresponding transforms in SVG are rendered. Here is a rendering of <i>robot.svg</i>:</p>
		<figure>
			<img src="./img/screenshot_7-7_0-22-36.png" width="400px"/>
			<figcaption>Rendering of <i>robot.svg</i></figcaption>
		</figure>

		<p>By modifying these transforms in the SVG file, you can make your robot do interesting things. Below is a version of my robot image, where the robot with various colors poses a running motion.</p>

		<figure>
			<img src="./img/screenshot_7-7_0-22-38.png" width="400px"/>
			<figcaption>Rendering of <i>my_robot.svg</i></figcaption>
		</figure>

		<h2>Task 4: Barycentric coordinates</h2>
		<p>The barycentric coordinate system is a coordinate system that expresses the location of a point within a triangle relative to each vertex of the triangle. For a point \(P\) and a triangle \(ABC\), the barycentric coordinate of the point is \((\alpha, \beta, \gamma)\) such that: </p>

		\[ P = \alpha A + \beta B + \gamma C, \quad \alpha + \beta + \gamma = 1 \]

		<p>Each component of the coordinate represents a proportional distance from the opposite side of the corresponding vertex. From this perspective, for the points in 2D space, the formulas for each component of the barycentric coordinate of \(P\) are:</p>

		\[ \alpha = \frac{L_{BC}(P)}{L_{BC}(A)}, \quad \beta = \frac{L_{CA}(P)}{L_{CA}(B)}, \quad \gamma = 1 - \alpha - \beta \]
		
		<p>where \(L_{l}(P)\) is the function measuring the relative distance of the point \(P\) from the line \(l\). (See Task 1) </p>
		
		<p>Alternatively, the coordinate of a point can be interpreted as the mass of each vertex for that point to become the barycenter of the triangle. From this perspective, each component represented by a coordinate acts as a "weight" in the weighted average of the vertices of the triangle. Through the barycentric coordinate system, it is possible to have a one-to-one correspondence for each point between different triangles.</p>

		<p>Below is an example of visualizing a barycentric coordinate system. In a triangle, each vertex has a color corresponding to each pure RGB component, and the color of each pixel within the triangle is a weighted average of the weights corresponding to the barycentric coordinate of that point.</p>
		
		<figure>
			<img src="./img/screenshot_7-7_0-30-44.png" width="400px"/>
			<figcaption>Color triangle representing barycentric coordinates</i></figcaption>
		</figure>

		<p>The barycentric coordinate system allows us to represent gradients within a triangle. The following color wheel is a rendering that utilizes this.</p>
		
		<figure>
			<img src="./img/screenshot_7-7_0-30-46.png" width="400px"/>
			<figcaption>Color wheel</i></figcaption>
		</figure>

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		<p>Texture mapping is mapping an existing texture to the shape of the screen. As a simple case, pixel sampling is performed by sampling the texture coordinates \((u,v)\) corresponding to the coordinates \((x,y)\) of each pixel sample of the target image, where the correspondence between the two coordinates is performed through barycentric coordinates. When sampling the points in the texture, there are two sampling methods: nearest sampling and bilinear sampling. Nearest sampling simply takes a sample of the nearest pixel in the grid, while bilinear sampling takes four pixels around the sample and linearly interpolates them in two dimensions. While bilinear sampling is more complex than nearest sampling, bilinear sampling can produce smoother images.</p>

		<p>Below are image renderings of the same svg file, showing the differences between different parameter options.</p>

		<div class="table-container">
			<table class="table">
			  <tr>
				<td>
				  <img src="./img/screenshot_7-8_1-32-23.png" width="400px"/>
				  <figcaption>nearest sampling, 1 sample per pixel</figcaption>
				</td>
				<td>
				  <img src="./img/screenshot_7-8_1-32-26.png" width="400px"/>
				  <figcaption>nearest sampling, 16 samples per pixel</figcaption>
				</td>
				</tr>
				<tr>
				<td>
				  <img src="./img/screenshot_7-8_1-32-30.png" width="400px"/>
				  <figcaption>bilinear sampling, 1 sample per pixel</figcaption>
				</td>
				<td>
				  <img src="./img/screenshot_7-8_1-32-32.png" width="400px"/>
				  <figcaption>bilinear sampling, 16 samples per pixel</figcaption>
				</td>
				</tr>
			</table>
		</div>

		<p>If you look at the images above, you can see that bilinear sampling has fewer line breaks and is relatively smoother than nearest sampling, even at lower sampling rates. This is because bilinear sampling takes into account surrounding samples in the texture and takes a weighted average.</p>

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>

		</div>
	</body>
</html>